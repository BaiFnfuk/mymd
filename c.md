## C语言

### 数据类型

- int	 整型 	4个字节
- short 	短整型	2个字节
- long	长整型    8个字节
- float    单精度浮点型    4个字节
- double    双精度浮点型    8个字节
- char    字符型    1个字节
- void    无类型

### 输出打印

- %d    十进制整型
- %c    单字符
- %s    字符串
- %o   八进制整型
- %x / %X     十六进制整型小写x时打印小写，X时打印大写
- %u    无符号整型
- %hd    十进制短整型
- %ld      十进制长整型
- %f    十进制float
- %lf    十进制double

### 正数与负数

- 正数的最高位是0
- 负数的最高位是1



### 原码，反码与补码

- 原码就是一个数的二进制形式

- 正数的反码就是原码本身

- 负数的反码是将原码中除符号位以外的所有位取反

  ```c
  short a = 6;
  // 原码与反码都是 0000 0000 0000 0110
  short b = -18;
  // 原码为 1000 0000 0001 0010
  // 反码为 1111 1111 1110 1101
  ```

- 正数的补码的就是原码本身

- 负数的补码是其反码加1

  ```c
  short a = 6;
  // 原码，反码，补码都是 0000 0000 0000 0110
  short b = -18;
  // 原码为 1000 0000 0001 0010
  // 反码为 1111 1111 1110 1101
  // 补码为 1111 1111 1110 1110
  ```

- 反码跟补码只对负数有实际意义，正数都是一样的

### 缓冲区

- 缓冲区（Buffer）又称为缓存（Cache），是内存空间的一部分。也就是说，计算机在内存中预留了一定的存储空间，用来暂时保存输入或输出的数据，这部分预留的空间就叫做缓冲区（缓存）。
- 缓冲区是为了让低速的输入输出设备和高速的用户程序能够协调工作，并降低输入输出设备的读写次数。

#### 缓冲区类型

- 根据缓冲区对应的是输入设备还是输出设备，可以分为**输入缓冲区**和**输出缓冲区**。

- 根据数据刷新（也可以称为清空缓冲区，就是将缓冲区中的数据“倒出”）的时机，可以分为**全缓冲**、**行缓冲**、**不带缓冲**。

   - 全缓冲区

     当缓冲区被填满以后才进行真正的输入输出操作。缓冲区的大小都有限制的，比如 1KB、4MB 等，数据量达到最大值时就清空缓冲区。全缓冲的典型代表是对硬盘文件的读写。

  - 行缓冲区

    当在输入或者输出的过程中遇到换行符时，才执行真正的输入输出操作。行缓冲的典型代表就是标准输入设备（也即键盘）和标准输出设备（也即显示器）。

  - 不带缓冲区

    不带缓冲区，数据就没有地方缓存，必须立即进行输入输出。

### 运算优先级

- 赋值运算符(=) < &&和|| < 关系运算符 < 算术运算符 < 非(!)

### 字符串

```c
// 字符串就是字符数组
char str[30] = {"Hello World!"};
char str[30] = "Hello World!"; // 这种形式更加简洁，实际开发中常用
// 也可以省略字符数组的长度
char str[] = {"Hello World!"};
char str[] = "Hello World!";  //这种形式更加简洁，实际开发中常用
```

- 这里需要留意一个坑，字符数组只有在定义时才能将整个字符串一次性地赋值给它，一旦定义完了，就只能一个字符一个字符地赋值了。

```c
char str[7];
str = "abc123";  //错误的
// 正确的方法
char str[] = "abc123";
```

### 数组

- C语言中的数组是静态的，一旦定义后长度就不能改变了，大家要注意这一点，不要尝试去插入或删除元素。数组一旦被定义后，占用的内存空间就是固定的，容量就是不可改变的，既不能在任何位置插入元素，也不能在任何位置删除元素，只能读取和修改元素。

#### 冒泡排序

```c
#include <stdio.h>
int main(){
    int nums[10] = {4, 5, 2, 10, 7, 1, 8, 3, 6, 9};
    int i, j, temp;
    //冒泡排序算法：进行 n-1 轮比较
    for(i=0; i<10-1; i++){
        //每一轮比较前 n-1-i 个，也就是说，已经排序好的最后 i 个不用比较
        for(j=0; j<10-1-i; j++){
            if(nums[j] > nums[j+1]){
                temp = nums[j];
                nums[j] = nums[j+1];
                nums[j+1] = temp;
            }
        }
    }
   
    //输出排序后的数组
    for(i=0; i<10; i++){
        printf("%d ", nums[i]);
    }
    printf("\n");
   
    return 0;
}
```

### 指针

```c
int *p1[6]; // 指针数组
int *(p2[6]); // 指针数组，与上面的形式等价
int (*p3)[6]; // 二维数组指针
int (*p4)(int, int); // 函数指针
```

### 结构体

```c
// 定义一个结构体
struct stu {
  	char *name;
    int num;
    int age;
    char group;
    float score;
}; // 注意最后的分号不能少
// stu是我们定义的结构体名

// 定义结构体变量
struct stu stu1, stu2;
```
